give @s minecraft:written_book{title: "x86 Assembly Language", author: "Wikipedia, the Free Encyclopedia", resolved: 1b, pages: ["[{\"text\":\"x86 assembly language is a family of backward-compatible assembly languages, which provide some level of compatibility all the way back to the Intel 8008 introduced in April 1972. x86 assembly languages are used to produce object code for the x86 class of \"}]","[{\"text\":\"processors. Like all assembly languages, it uses short mnemonics to represent the fundamental instructions that the CPU in a computer can understand and follow. Compilers sometimes produce assembly code as an intermediate step when translating a high level program \"}]","[{\"text\":\"into machine code.  Regarded as a programming language, assembly coding is machine-specific and low level. Assembly languages are more typically used for detailed and time critical applications such as small real-time embedded systems or operating system kernels \"}]","[{\"text\":\"and device \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n== Mnemonics and opcodes \\n\\n\\n\\nEach x86 assembly instruction is \"}]","[{\"text\":\"represented by a mnemonic which, often combined with one or more operands, translates to one or more bytes called an opcode; the NOP instruction translates to 0x90, for instance and the HLT instruction translates to 0xF4. There are potential opcodes with no \"}]","[{\"text\":\"documented mnemonic which different processors may interpret differently, making a program using them behave inconsistently or even generate an exception on some processors. These opcodes often turn up in code writing competitions as a way to make the code smaller, \"}]","[{\"text\":\"faster, more elegant or just show off the author's \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n== Syntax \\n\\n\\nx86 assembly \"}]","[{\"text\":\"language has two main syntax branches: Intel syntax and AT&T syntax. Intel syntax is dominant in the DOS and Windows world, and AT&T syntax is dominant in the Unix world, since Unix was created at AT&T Bell \\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nHere is a summary of the main differences between Intel syntax and AT&T \\n\\n\\n\\n\\n\\n\\n\\n\\nMany x86 assemblers use Intel syntax, including NASM, \"}]","[{\"text\":\"FASM, MASM, TASM, and YASM. GAS, which originally used AT&T syntax,  has supported both syntaxes since version 2.10 via the .intel_syntax directive. A quirk in the AT&T syntax for x86 is that x87 operands are reversed, an inherited bug from the original AT&T \"}]","[{\"text\":\"assembler.The AT&T syntax is nearly universal to all other architectures with the same mov order; it was originally a syntax for PDP-11 assembly. The Intel syntax is specific to the x86 architecture, and is the one used in the x86 platform's \\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\n== Registers \\n\\n\\n\\nx86 processors have a collection of registers available to be used as stores for binary data. Collectively the data and address registers are called the general registers. Each register has a special purpose in addition to \"}]","[{\"text\":\"what they can all do: \\nAX multiply/divide, string load & \\n\\n\\n\\n\\n\\nBX index register for \\n\\n\\n\\n\\nCX count for \"}]","[{\"text\":\"string operations & \\n\\n\\n\\n\\n\\n\\nDX port address for IN and \\n\\n\\n\\nSP points to top of the \\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nBP points to base of the stack \\n\\n\\n\\n\\n\\nSI points to a source in stream \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nDI points to a destination in stream operationsAlong with the general registers there are additionally \\n\\n\\n\\n\\n\\nIP instruction \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nsegment registers (CS, DS, ES, FS, GS, SS) which determine where a 64k segment starts  (no FS & GS in 80286 & \\n\\n\\n\\n\\n\\n\\n\\n\\nextra extension \"}]","[{\"text\":\"registers (MMX, 3DNow!, SSE, etc.) (Pentium & later only).The IP register points to the memory offset of the next instruction in the code segment (it points to the first byte of the instruction). The IP register cannot be accessed by the programmer \\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nThe x86 registers can be used by using the MOV instructions. For example, in Intel \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n== Segmented \"}]","[{\"text\":\"addressing \\n\\n\\nThe x86 architecture in real and virtual 8086 mode uses a process known as segmentation to address memory, not the flat memory model used in many other environments.  Segmentation involves composing a memory address from two \"}]","[{\"text\":\"parts, a segment and an offset; the segment points to the beginning of a 64 KB (64×210) group of addresses and the offset determines how far from this beginning address the desired address is.  In segmented addressing, two registers are required for a complete \"}]","[{\"text\":\"memory address. One to hold the segment, the other to hold the offset.  In order to translate back into a flat address, the segment value is shifted four bits left (equivalent to multiplication by 24 or 16) then added to the offset to form the full address, which \"}]","[{\"text\":\"allows breaking the 64k barrier through clever choice of addresses, though it makes programming considerably more \\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nIn real mode/protected only, for example, if DS contains the hexadecimal number 0xDEAD and DX contains the number 0xCAFE they would together point to the memory address 0xDEAD * 0x10 + 0xCAFE = 0xEB5CE. Therefore, the CPU can address up to 1,048,576 bytes (1 MB) \"}]","[{\"text\":\"in real mode. By combining segment and offset values we find a 20-bit \\n\\n\\n\\n\\n\\n\\n\\n\\nThe original IBM PC restricted programs to 640 KB but \"}]","[{\"text\":\"an expanded memory specification was used to implement a bank switching scheme that fell out of use when later operating systems, such as Windows, used the larger address ranges of newer processors and implemented their own virtual memory \\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nProtected mode, starting with the Intel 80286, was utilized by OS/2. Several shortcomings, such as the inability to access the BIOS and the inability to switch back to real mode without resetting the processor, prevented widespread usage. The 80286 was also still \"}]","[{\"text\":\"limited to addressing memory in 16-bit segments, meaning only 216 bytes (64 kilobytes) could be accessed at a \\n\\n\\n\\n\\n\\nTo access the extended functionality of the 80286, the operating system \"}]","[{\"text\":\"would set the processor into protected mode, enabling 24-bit addressing and thus 224 bytes of memory (16 \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nIn protected mode, the segment selector can be broken down into three parts: a 13-bit index, a Table Indicator bit that determines whether the entry is in the GDT or LDT and a 2-bit Requested Privilege Level; see x86 memory \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nWhen referring to an address with a segment and an offset the notation of segment:offset is used, so in the above example the flat address 0xEB5CE can be written as 0xDEAD:0xCAFE or as a segment and offset register pair; \\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nThere are some special combinations of segment registers and general registers that point to important \\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\nCS:IP (CS is Code Segment, IP is Instruction Pointer) points to the address where the processor will fetch the next byte of \\n\\n\\n\\n\\n\\nSS:SP (SS is Stack Segment, SP is Stack Pointer) points \"}]","[{\"text\":\"to the address of the top of the stack, i.e. the most recently pushed \\n\\n\\n\\n\\n\\nDS:SI (DS is Data Segment, SI is Source Index) is often used to point to string data that is about to be copied \"}]","[{\"text\":\"to \\n\\n\\n\\n\\n\\n\\nES:DI (ES is Extra Segment, DI is Destination Index) is typically used to point to the destination for a string copy, as mentioned above.The Intel \"}]","[{\"text\":\"80386 featured three operating modes: real mode, protected mode and virtual mode.  The protected mode which debuted in the 80286 was extended to allow the 80386 to address up to 4 GB of memory, the all new virtual 8086 mode (VM86) made it possible to run one or \"}]","[{\"text\":\"more real mode programs in a protected environment which largely emulated real mode, though some programs were not compatible (typically as a result of memory addressing tricks or using unspecified \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nThe 32-bit flat memory model of the 80386's extended protected mode may be the most important feature change for the x86 processor family until AMD released x86-64 in 2003, as it helped drive large scale adoption of Windows 3.1 (which relied on protected mode) \"}]","[{\"text\":\"since Windows could now run many applications at once, including DOS applications, by using virtual memory and simple \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n== Execution modes \\n\\n\\n\\nThe x86 processors support five modes of operation for x86 code, Real Mode, Protected Mode, Long Mode, Virtual 86 Mode, and System Management Mode, in which some instructions are available and others are \"}]","[{\"text\":\"not.  A 16-bit subset of instructions are available on the 16-bit x86 processors, which are the 8086, 8088, 80186, 80188, and 80286.  These instructions are available in real mode on all x86 processors, and in 16-bit protected mode (80286 onwards), additional \"}]","[{\"text\":\"instructions relating to protected mode are available.  On the 80386 and later, 32-bit instructions (including later extensions) are also available in all modes, including real mode; on these CPUs, V86 mode and 32-bit protected mode are added, with additional \"}]","[{\"text\":\"instructions provided in these modes to manage their features.  SMM, with some of its own special instructions, is available on some Intel i386SL, i486 and later CPUs.  Finally, in long mode (AMD Opteron onwards), 64-bit instructions, and more registers, are also \"}]","[{\"text\":\"available.  The instruction set is similar in each mode but memory addressing and word size vary, requiring different programming \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nThe modes in which x86 code can be executed in \\n\\n\\n\\n\\n\\nReal mode \\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n20-bit segmented memory address space (meaning that only 1 MB of memory can be addressed—actually, slightly more), direct software access to peripheral hardware, and no concept of memory protection or multitasking at the hardware level. Computers that use BIOS \"}]","[{\"text\":\"start up in this \\n\\n\\n\\n\\n\\nProtected mode (16-bit and \\n\\n\\n\\n\\n\\n\\n\\nExpands \"}]","[{\"text\":\"addressable physical memory to 16 MB and addressable virtual memory to 1 GB. Provides privilege levels and protected memory, which prevents programs from corrupting one another. 16-bit protected mode (used during the end of the DOS era) used a complex, \"}]","[{\"text\":\"multi-segmented memory model. 32-bit protected mode uses a simple, flat memory \\n\\n\\n\\n\\n\\n\\nLong mode \\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nMostly an extension of the 32-bit (protected mode) instruction set, but unlike the 16–to–32-bit transition, many instructions were dropped in the 64-bit mode. Pioneered by \\n\\n\\n\\n\\nVirtual 8086 mode \\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nA special hybrid operating mode that allows real mode programs and operating systems to run while under the control of a protected mode supervisor operating \\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nSystem Management Mode \\n\\n\\n\\n\\n\\n\\n\\n\\nHandles system-wide functions like power management, system hardware control, and proprietary \"}]","[{\"text\":\"OEM designed code. It is intended for use only by system firmware,. All normal execution, including the operating system, is suspended. An alternate software system (which usually resides in the computer's firmware, or a hardware-assisted debugger) is then executed \"}]","[{\"text\":\"with high \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n=== Switching modes \\n\\n\\n\"}]","[{\"text\":\"\\nThe processor runs in real mode immediately after power on, so an operating system kernel, or other program, must explicitly switch to another mode if it wishes to run in anything but real mode.  Switching modes is accomplished by modifying certain bits of the \"}]","[{\"text\":\"processor's control registers after some preparation, and some additional setup may be required after the \\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n=== Examples \\n\\n\\n\\nWith a computer running legacy BIOS, the BIOS and the boot loader is running in Real mode, then the 64-bit operating system kernel checks and switches the CPU into Long mode and then starts new kernel-mode \"}]","[{\"text\":\"threads running 64-bit \\n\\n\\n\\n\\n\\nWith a computer running UEFI, the UEFI firmware (except CSM and legacy Option ROM), the UEFI boot loader and the UEFI operating system kernel is all \"}]","[{\"text\":\"running in Long \\n\\n\\n\\n\\n\\n\\n\\n== Instruction types \\n\\n\\nIn general, the features of the modern x86 instruction set \\n\\n\\n\"}]","[{\"text\":\"\\n\\nA compact \\n\\n\\n\\n\\n\\n\\n\\n\\nVariable length and alignment independent (encoded as little endian, as is all data in the x86 \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nMainly one-address and two-address instructions, that is to say, the first operand is also the \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nMemory operands as both source and destination are supported (frequently used to read/write stack elements addressed using small immediate \\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nBoth general and implicit register usage; although all seven (counting ebp) general registers in 32-bit mode, and all fifteen (counting rbp) general registers in 64-bit mode, can be freely used as accumulators or for addressing, most of them are also implicitly \"}]","[{\"text\":\"used by certain (more or less) special instructions; affected registers must therefore be temporarily preserved (normally stacked), if active during such instruction \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nProduces conditional flags implicitly through most integer ALU \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nSupports various addressing modes including immediate, offset, and scaled index but not PC-relative, except jumps (introduced as an improvement in the x86-64 \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nIncludes floating point to a stack of \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nContains special support for atomic \"}]","[{\"text\":\"read-modify-write instructions (xchg, cmpxchg/cmpxchg8b, xadd, and integer instructions which combine with the lock \\n\\n\\n\\n\\n\\n\\n\\nSIMD instructions \"}]","[{\"text\":\"(instructions which perform parallel simultaneous single instructions on many operands encoded in adjacent cells of wider \\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\n=== Stack instructions \\n\\n\\n\\nThe x86 architecture has hardware support for an execution stack mechanism. Instructions such as push, pop, call and ret are used with the properly set up stack to pass parameters, to \"}]","[{\"text\":\"allocate space for local data, and to save and restore call-return points. The ret size instruction is very useful for implementing space efficient (and fast) calling conventions where the callee is responsible for reclaiming stack space occupied by \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nWhen setting up a stack frame to hold local data of a recursive procedure there are several choices; the high level enter instruction (introduced with the 80186) takes a procedure-nesting-depth argument as well as a local size argument, and may be faster than more \"}]","[{\"text\":\"explicit manipulation of the registers (such as push bp ; mov bp, sp ; sub sp, size).  Whether it is faster or slower depends on the particular x86-processor implementation as well as the calling convention used by the compiler, programmer or particular program \"}]","[{\"text\":\"code; most x86 code is intended to run on x86-processors from several manufacturers and on different technological generations of processors, which implies highly varying microarchitectures and microcode solutions as well as varying gate- and transistor-level \"}]","[{\"text\":\"design \\n\\n\\n\\n\\n\\n\\n\\n\\nThe full range of addressing modes (including immediate and base+offset) even for instructions such as push and \"}]","[{\"text\":\"pop, makes direct usage of the stack for integer, floating point and address data simple, as well as keeping the ABI specifications and mechanisms relatively simple compared to some RISC architectures (require more explicit call stack \\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\n\\n=== Integer ALU instructions \\n\\n\\n\\nx86 assembly has the standard mathematical operations, add, sub, mul, with idiv; the logical operators and, or, xor, neg; bitshift arithmetic and logical, sal/sar, shl/shr; rotate with and \"}]","[{\"text\":\"without carry, rcl/rcr, rol/ror, a complement of BCD arithmetic instructions, aaa, aad, daa and \\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n=== Floating-point instructions \\n\\n\\n\\nx86 assembly language includes instructions for a stack-based floating-point unit (FPU). The FPU was an optional separate coprocessor for the 8086 through the 80386, it was an on-chip \"}]","[{\"text\":\"option for the 80486 series, and it is a standard feature in every Intel x86 CPU since the 80486, starting with the Pentium. The FPU instructions include addition, subtraction, negation, multiplication, division, remainder, square roots, integer truncation, \"}]","[{\"text\":\"fraction truncation, and scale by power of two. The operations also include conversion instructions, which can load or store a value from memory in any of the following formats: binary-coded decimal, 32-bit integer, 64-bit integer, 32-bit floating-point, 64-bit \"}]","[{\"text\":\"floating-point or 80-bit floating-point (upon loading, the value is converted to the currently used floating-point mode). x86 also includes a number of transcendental functions, including sine, cosine, tangent, arctangent, exponentiation with the base 2 and \"}]","[{\"text\":\"logarithms to bases 2, 10, or \\n\\n\\nThe stack register to stack register format of the instructions is usually fop st, st(n) or fop st(n), st, where st is equivalent to st(0), and st(n) is one of the 8 stack registers (st(0), st(1), ..., \"}]","[{\"text\":\"st(7)). Like the integers, the first operand is both the first source operand and the destination operand. fsubr and fdivr should be singled out as first swapping the source operands before performing the subtraction or division. The addition, subtraction, \"}]","[{\"text\":\"multiplication, division, store and comparison instructions include instruction modes that pop the top of the stack after their operation is complete. So, for example, faddp st(1), st performs the calculation st(1) = st(1) + st(0), then removes st(0) from the top \"}]","[{\"text\":\"of stack, thus making what was the result in st(1) the top of the stack in \\n\\n\\n\\n\\n\\n\\n\\n\\n=== SIMD instructions \\n\\n\\n\\nModern x86 CPUs \"}]","[{\"text\":\"contain SIMD instructions, which largely perform the same operation in parallel on many values encoded in a wide SIMD register. Various instruction technologies support different operations on different register sets, but taken as complete whole (from MMX to \"}]","[{\"text\":\"SSE4.2) they include general computations on integer or floating point arithmetic (addition, subtraction, multiplication, shift, minimization, maximization, comparison, division or square root). So for example, paddw mm0, mm1 performs 4 parallel 16-bit (indicated \"}]","[{\"text\":\"by the w) integer adds (indicated by the padd) of mm0 values to mm1 and stores the result in mm0. Streaming SIMD Extensions or SSE also includes a floating point mode in which only the very first value of the registers is actually modified (expanded in SSE2). Some \"}]","[{\"text\":\"other unusual instructions have been added including a sum of absolute differences (used for motion estimation in video compression, such as is done in MPEG) and a 16-bit multiply accumulation instruction (useful for software-based alpha-blending and digital \"}]","[{\"text\":\"filtering). SSE (since SSE3) and 3DNow! extensions include addition and subtraction instructions for treating paired floating point values like complex \\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nThese instruction sets also include numerous fixed sub-word instructions for shuffling, inserting and extracting the values around within the registers. In addition there are instructions for moving data between the integer registers and XMM (used in SSE)/FPU \"}]","[{\"text\":\"(used in MMX) \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n=== Data manipulation instructions \\n\\n\\n\"}]","[{\"text\":\"\\nThe x86 processor also includes complex addressing modes for addressing memory with an immediate offset, a register, a register with an offset, a scaled register with or without an offset, and a register with an optional offset and another scaled register. So for \"}]","[{\"text\":\"example, one can encode mov eax, [Table + ebx + esi*4] as a single instruction which loads 32 bits of data from the address computed as (Table + ebx + esi * 4) offset from the ds selector, and stores it to the eax register. In general x86 processors can load and \"}]","[{\"text\":\"use memory matched to the size of any register it is operating on. (The SIMD instructions also include half-load \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nThe x86 instruction set includes string load, store, move, scan and compare instructions (lods, stos, movs, scas and cmps) which perform each operation to a specified size (b for 8-bit byte, w for 16-bit word, d for 32-bit double word) then increments/decrements \"}]","[{\"text\":\"(depending on DF, direction flag) the implicit address register (si for lods, di for stos and scas, and both for movs and cmps). For the load, store and scan operations, the implicit target/source/comparison register is in the al, ax or eax register (depending on \"}]","[{\"text\":\"size). The implicit segment registers used are ds for si and es for di. The cx or ecx register is used as a decrementing counter, and the operation stops when the counter reaches zero or (for scans and comparisons) when inequality is \\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nThe stack is implemented with an implicitly decrementing (push) and incrementing (pop) stack pointer. In 16-bit mode, this implicit stack pointer is addressed as SS:[SP], in 32-bit mode it is SS:[ESP], and in 64-bit mode it is [RSP]. The stack pointer actually \"}]","[{\"text\":\"points to the last value that was stored, under the assumption that its size will match the operating mode of the processor (i.e., 16, 32, or 64 bits) to match the default width of the push/pop/call/ret instructions. Also included are the instructions enter and \"}]","[{\"text\":\"leave which reserve and remove data from the top of the stack while setting up a stack frame pointer in bp/ebp/rbp. However, direct setting, or addition and subtraction to the sp/esp/rsp register is also supported, so the enter/leave instructions are generally \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nThis code in the beginning of a \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n...is functionally equivalent to \\n\\n\\n\\n\"}]","[{\"text\":\"\\nOther instructions for manipulating the stack include pushf/popf for storing and retrieving the (E)FLAGS register. The pusha/popa instructions will store and retrieve the entire integer register state to and from the \\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nValues for a SIMD load or store are assumed to be packed in adjacent positions for the SIMD register and will align them in sequential little-endian order. Some SSE load and store instructions require 16-byte alignment to function properly. The SIMD instruction \"}]","[{\"text\":\"sets also include \\\"prefetch\\\" instructions which perform the load but do not target any register, used for cache loading. The SSE instruction sets also include non-temporal store instructions which will perform stores straight to memory without performing a cache \"}]","[{\"text\":\"allocate if the destination is not already cached (otherwise it will behave like a regular \\n\\n\\n\\n\\n\\n\\n\\nMost generic integer and floating point (but no SIMD) \"}]","[{\"text\":\"instructions can use one parameter as a complex address as the second source parameter. Integer instructions can also accept one memory parameter as a destination \\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\n== Program flow \\n\\n\\nThe x86 assembly has an unconditional jump operation, jmp, which can take an immediate address, a register or an indirect address as a parameter (note that most RISC processors only support a link register or short immediate \"}]","[{\"text\":\"displacement for \\n\\n\\n\\n\\n\\n\\n\\n\\n\\nAlso supported are several conditional jumps, including jz (jump on zero), jnz (jump on \"}]","[{\"text\":\"non-zero), jg (jump on greater than, signed), jl (jump on less than, signed), ja (jump on above/greater than, unsigned), jb (jump on below/less than, unsigned). These conditional operations are based on the state of specific bits in the (E)FLAGS register. Many \"}]","[{\"text\":\"arithmetic and logic operations set, clear or complement these flags depending on their result. The comparison cmp (compare) and test instructions set the flags as if they had performed a subtraction or a bitwise AND operation, respectively, without altering the \"}]","[{\"text\":\"values of the operands. There are also instructions such as clc (clear carry flag) and cmc (complement carry flag) which work on the flags directly. Floating point comparisons are performed via fcom or ficom instructions which eventually have to be converted to \"}]","[{\"text\":\"integer \\n\\n\\n\\n\\n\\n\\nEach jump operation has three different forms, depending on the size of the operand. A short jump uses an 8-bit signed operand, which is a relative \"}]","[{\"text\":\"offset from the current instruction. A near jump is similar to a short jump but uses a 16-bit signed operand  (in real or protected mode) or a 32-bit signed operand (in 32-bit protected mode only). A far jump is one that uses the full segment base:offset value as \"}]","[{\"text\":\"an absolute address. There are also indirect and indexed forms of each of \\n\\n\\n\\n\\n\\n\\nIn addition to the simple jump operations, there are the call (call a subroutine) and ret \"}]","[{\"text\":\"(return from subroutine) instructions. Before transferring control to the subroutine, call pushes the segment offset address of the instruction following the call onto the stack; ret pops this value off the stack, and jumps to it, effectively returning the flow of \"}]","[{\"text\":\"control to that part of the program. In the case of a far call, the segment base is pushed following the offset; far ret pops the offset and then the segment base to \\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nThere are also two similar instructions, int (interrupt), which saves the current (E)FLAGS register value on the stack, then performs a far call, except that instead of an address, it uses an interrupt vector, an index into a table of interrupt handler addresses. \"}]","[{\"text\":\"Typically, the interrupt handler saves all other CPU registers it uses, unless they are used to return the result of an operation to the calling program (in software called interrupts). The matching return from interrupt instruction is iret, which restores the \"}]","[{\"text\":\"flags after returning. Soft Interrupts of the type described above are used by some operating systems for system calls, and can also be used in debugging hard interrupt handlers. Hard interrupts are triggered by external hardware events, and must preserve all \"}]","[{\"text\":\"register values as the state of the currently executing program is unknown. In Protected Mode, interrupts may be set up by the OS to trigger a task switch, which will automatically save all registers of the active \\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\n== Examples \\n\\n\\n\\n\\n=== \\\"Hello world!\\\" program for DOS in MASM style assembly \\n\\n\\n\\nUsing interrupt 21h for output – other samples use libc's printf to print to \\n\\n\\n\"}]","[{\"text\":\"\\n=== \\\"Hello world!\\\" program for Windows in MASM style assembly \\n\\n\\n\\n\\n\\n=== \\\"Hello world!\\\" program for Windows in NASM style assembly \\n\\n\\n\\n\\n\\n=== \\\"Hello world!\\\" program for \"}]","[{\"text\":\"Linux in NASM style assembly \\n\\n\\n\\n\\n\\n=== \\\"Hello world!\\\" program for Linux in NASM style assembly using the C standard library \\n\\n\\n\\n\\n\\n=== \\\"Hello world!\\\" program for 64-bit mode Linux in \"}]","[{\"text\":\"NASM style assembly \\n\\n\\n\\n\\nRunning it under strace verifies that no extra system calls are made in the process.  The printf version would make many more system calls to initialize libc and do \"}]","[{\"text\":\"dynamic linking.  But this is a static executable because we linked using ld without -pie or any shared libraries; the only instructions that run in user-space are the ones you \\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\n=== Using the flags register \\n\\n\\n\\nFlags are heavily used for comparisons in the x86 architecture. When a comparison is made between two data, the CPU sets the relevant flag or flags. Following this, conditional jump \"}]","[{\"text\":\"instructions can be used to check the flags and branch to code that should run, \\n\\n\\n\\n\\n\\n\\nFlags are also used in the x86 architecture to turn on and off certain \"}]","[{\"text\":\"features or execution modes. For example, to disable all maskable interrupts, you can use the \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\nThe flags register can also be directly accessed. The low 8 bits of the flag register can be loaded into ah using the lahf instruction. The entire flags register can also be moved on and off the stack using the instructions pushf, popf, int (including into) and \\n\\n\"}]","[{\"text\":\"\\n\\n=== Using the instruction pointer register \\n\\n\\n\\nThe instruction pointer is called ip in 16-bit mode, eip in 32-bit mode, and rip in 64-bit mode.  The instruction pointer register points to the memory address which the \"}]","[{\"text\":\"processor will next attempt to execute; it cannot be directly accessed in 16-bit or 32-bit mode, but a sequence like the following can be written to put the address of next_line into \\n\\n\\n\\n\\n\\nThis sequence of \"}]","[{\"text\":\"instructions generates position-independent code because call takes an instruction-pointer-relative immediate operand describing the offset in bytes of the target instruction from the next instruction (in this case \\n\\n\\n\"}]","[{\"text\":\"\\nWriting to the instruction pointer is simple — a jmp instruction sets the instruction pointer to the target address, so, for example, a sequence like the following will put the contents of eax into \\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\nIn 64-bit mode, instructions can reference data relative to the instruction pointer, so there is less need to copy the value of the instruction pointer to another \\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\n\\n== See also \\n\\n\\nAssembly \\n\\n\\n\\n\\n\\n\\n\\n\\nX86 instruction \\n\\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nX86 \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nCPU \\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nList of \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nSelf-modifying \\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\n\\n\\n== References \\n\\n\\n\\n\\n== Further reading \\n\\n\\n\\n\\n=== Manuals \\n\\n\\n\\nIntel 64 and IA-32 Software Developer \\n\\n\\n\\n\\n\\n\\n\"}]","[{\"text\":\"\\nAMD64 Architecture Programmer's Manual (Volume \\n\\n\\n\\n\\n\\n\\n=== Books \\n\\n\\n\\nEd, Jorgensen (May 2018). x86-64 Assembly Language \"}]","[{\"text\":\"Programming with Ubuntu (PDF) (1.0.97 ed.). p. 367.\"}]"]} 1

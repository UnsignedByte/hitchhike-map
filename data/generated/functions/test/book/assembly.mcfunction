give @s minecraft:written_book{title: "x86 Assembly Language", author: "Wikipedia, the Free Encyclopedia", resolved: 1b, pages: ["[{\"text\":\"x86 assembly language is a family of backward-compatible assembly languages, which provide some level of compatibility all the way back to the Intel 8008 introduced in April 1972. x86 assembly languages are used to produce object code for the x86 class of processors\"}]","[{\"text\":\". Like all assembly languages, it uses short mnemonics to represent the fundamental instructions that the CPU in a computer can understand and follow. Compilers sometimes produce assembly code as an intermediate step when translating a high level program into machin\"}]","[{\"text\":\"e code.  Regarded as a programming language, assembly coding is machine-specific and low level. Assembly languages are more typically used for detailed and time critical applications such as small real-time embedded systems or operating system kernels and device dri\"}]","[{\"text\":\"vers.\\n\\n\\n== Mnemonics and opcodes ==\\n\\nEach x86 assembly instruction is represented by a mnemonic which, often combined with one or more operands, translates to one or more bytes called an opcode; the NOP instruction translates to 0x90, for instance and the HLT instru\"}]","[{\"text\":\"ction translates to 0xF4. There are potential opcodes with no documented mnemonic which different processors may interpret differently, making a program using them behave inconsistently or even generate an exception on some processors. These opcodes often turn up i\"}]","[{\"text\":\"n code writing competitions as a way to make the code smaller, faster, more elegant or just show off the author's prowess.\\n\\n\\n== Syntax ==\\nx86 assembly language has two main syntax branches: Intel syntax and AT&T syntax. Intel syntax is dominant in the DOS and Window\"}]","[{\"text\":\"s world, and AT&T syntax is dominant in the Unix world, since Unix was created at AT&T Bell Labs.\\nHere is a summary of the main differences between Intel syntax and AT&T syntax:\\n\\nMany x86 assemblers use Intel syntax, including NASM, FASM, MASM, TASM, and YASM. GAS, \"}]","[{\"text\":\"which originally used AT&T syntax,  has supported both syntaxes since version 2.10 via the .intel_syntax directive. A quirk in the AT&T syntax for x86 is that x87 operands are reversed, an inherited bug from the original AT&T assembler.The AT&T syntax is nearly univ\"}]","[{\"text\":\"ersal to all other architectures with the same mov order; it was originally a syntax for PDP-11 assembly. The Intel syntax is specific to the x86 architecture, and is the one used in the x86 platform's documentation.\\n\\n\\n== Registers ==\\n\\nx86 processors have a collecti\"}]","[{\"text\":\"on of registers available to be used as stores for binary data. Collectively the data and address registers are called the general registers. Each register has a special purpose in addition to what they can all do: \\nAX multiply/divide, string load & store\\nBX index r\"}]","[{\"text\":\"egister for MOVE\\nCX count for string operations & shifts\\nDX port address for IN and OUT\\nSP points to top of the stack\\nBP points to base of the stack frame\\nSI points to a source in stream operations\\nDI points to a destination in stream operationsAlong with the genera\"}]","[{\"text\":\"l registers there are additionally the:\\n\\nIP instruction pointer\\nFLAGS\\nsegment registers (CS, DS, ES, FS, GS, SS) which determine where a 64k segment starts  (no FS & GS in 80286 & earlier)\\nextra extension registers (MMX, 3DNow!, SSE, etc.) (Pentium & later only).Th\"}]","[{\"text\":\"e IP register points to the memory offset of the next instruction in the code segment (it points to the first byte of the instruction). The IP register cannot be accessed by the programmer directly.\\nThe x86 registers can be used by using the MOV instructions. For ex\"}]","[{\"text\":\"ample, in Intel syntax:\\n\\n\\n== Segmented addressing ==\\nThe x86 architecture in real and virtual 8086 mode uses a process known as segmentation to address memory, not the flat memory model used in many other environments.  Segmentation involves composing a memory addre\"}]","[{\"text\":\"ss from two parts, a segment and an offset; the segment points to the beginning of a 64 KB (64×210) group of addresses and the offset determines how far from this beginning address the desired address is.  In segmented addressing, two registers are required for a co\"}]","[{\"text\":\"mplete memory address. One to hold the segment, the other to hold the offset.  In order to translate back into a flat address, the segment value is shifted four bits left (equivalent to multiplication by 24 or 16) then added to the offset to form the full address, w\"}]","[{\"text\":\"hich allows breaking the 64k barrier through clever choice of addresses, though it makes programming considerably more complex.\\nIn real mode/protected only, for example, if DS contains the hexadecimal number 0xDEAD and DX contains the number 0xCAFE they would togeth\"}]","[{\"text\":\"er point to the memory address 0xDEAD * 0x10 + 0xCAFE = 0xEB5CE. Therefore, the CPU can address up to 1,048,576 bytes (1 MB) in real mode. By combining segment and offset values we find a 20-bit address.\\nThe original IBM PC restricted programs to 640 KB but an expan\"}]","[{\"text\":\"ded memory specification was used to implement a bank switching scheme that fell out of use when later operating systems, such as Windows, used the larger address ranges of newer processors and implemented their own virtual memory schemes.\\nProtected mode, starting w\"}]","[{\"text\":\"ith the Intel 80286, was utilized by OS/2. Several shortcomings, such as the inability to access the BIOS and the inability to switch back to real mode without resetting the processor, prevented widespread usage. The 80286 was also still limited to addressing memor\"}]","[{\"text\":\"y in 16-bit segments, meaning only 216 bytes (64 kilobytes) could be accessed at a time.\\nTo access the extended functionality of the 80286, the operating system would set the processor into protected mode, enabling 24-bit addressing and thus 224 bytes of memory (16 \"}]","[{\"text\":\"megabytes).\\nIn protected mode, the segment selector can be broken down into three parts: a 13-bit index, a Table Indicator bit that determines whether the entry is in the GDT or LDT and a 2-bit Requested Privilege Level; see x86 memory segmentation.\\nWhen referring t\"}]","[{\"text\":\"o an address with a segment and an offset the notation of segment:offset is used, so in the above example the flat address 0xEB5CE can be written as 0xDEAD:0xCAFE or as a segment and offset register pair; DS:DX.\\nThere are some special combinations of segment registe\"}]","[{\"text\":\"rs and general registers that point to important addresses:\\n\\nCS:IP (CS is Code Segment, IP is Instruction Pointer) points to the address where the processor will fetch the next byte of code.\\nSS:SP (SS is Stack Segment, SP is Stack Pointer) points to the address of t\"}]","[{\"text\":\"he top of the stack, i.e. the most recently pushed byte.\\nDS:SI (DS is Data Segment, SI is Source Index) is often used to point to string data that is about to be copied to ES:DI.\\nES:DI (ES is Extra Segment, DI is Destination Index) is typically used to point to the \"}]","[{\"text\":\"destination for a string copy, as mentioned above.The Intel 80386 featured three operating modes: real mode, protected mode and virtual mode.  The protected mode which debuted in the 80286 was extended to allow the 80386 to address up to 4 GB of memory, the all new \"}]","[{\"text\":\"virtual 8086 mode (VM86) made it possible to run one or more real mode programs in a protected environment which largely emulated real mode, though some programs were not compatible (typically as a result of memory addressing tricks or using unspecified op-codes).\\nT\"}]","[{\"text\":\"he 32-bit flat memory model of the 80386's extended protected mode may be the most important feature change for the x86 processor family until AMD released x86-64 in 2003, as it helped drive large scale adoption of Windows 3.1 (which relied on protected mode) since \"}]","[{\"text\":\"Windows could now run many applications at once, including DOS applications, by using virtual memory and simple multitasking.\\n\\n\\n== Execution modes ==\\n\\nThe x86 processors support five modes of operation for x86 code, Real Mode, Protected Mode, Long Mode, Virtual 86 M\"}]","[{\"text\":\"ode, and System Management Mode, in which some instructions are available and others are not.  A 16-bit subset of instructions are available on the 16-bit x86 processors, which are the 8086, 8088, 80186, 80188, and 80286.  These instructions are available in real mo\"}]","[{\"text\":\"de on all x86 processors, and in 16-bit protected mode (80286 onwards), additional instructions relating to protected mode are available.  On the 80386 and later, 32-bit instructions (including later extensions) are also available in all modes, including real mode; \"}]","[{\"text\":\"on these CPUs, V86 mode and 32-bit protected mode are added, with additional instructions provided in these modes to manage their features.  SMM, with some of its own special instructions, is available on some Intel i386SL, i486 and later CPUs.  Finally, in long mod\"}]","[{\"text\":\"e (AMD Opteron onwards), 64-bit instructions, and more registers, are also available.  The instruction set is similar in each mode but memory addressing and word size vary, requiring different programming strategies.\\nThe modes in which x86 code can be executed in ar\"}]","[{\"text\":\"e:\\n\\nReal mode (16-bit)\\n20-bit segmented memory address space (meaning that only 1 MB of memory can be addressed—actually, slightly more), direct software access to peripheral hardware, and no concept of memory protection or multitasking at the hardware level. Comput\"}]","[{\"text\":\"ers that use BIOS start up in this mode.\\nProtected mode (16-bit and 32-bit)\\nExpands addressable physical memory to 16 MB and addressable virtual memory to 1 GB. Provides privilege levels and protected memory, which prevents programs from corrupting one another. 16-b\"}]","[{\"text\":\"it protected mode (used during the end of the DOS era) used a complex, multi-segmented memory model. 32-bit protected mode uses a simple, flat memory model.\\nLong mode (64-bit)\\nMostly an extension of the 32-bit (protected mode) instruction set, but unlike the 16–to–3\"}]","[{\"text\":\"2-bit transition, many instructions were dropped in the 64-bit mode. Pioneered by AMD.\\nVirtual 8086 mode (16-bit)\\nA special hybrid operating mode that allows real mode programs and operating systems to run while under the control of a protected mode supervisor opera\"}]","[{\"text\":\"ting system\\nSystem Management Mode (16-bit)\\nHandles system-wide functions like power management, system hardware control, and proprietary OEM designed code. It is intended for use only by system firmware,. All normal execution, including the operating system, is sus\"}]","[{\"text\":\"pended. An alternate software system (which usually resides in the computer's firmware, or a hardware-assisted debugger) is then executed with high privileges.\\n\\n\\n=== Switching modes ===\\nThe processor runs in real mode immediately after power on, so an operating syst\"}]","[{\"text\":\"em kernel, or other program, must explicitly switch to another mode if it wishes to run in anything but real mode.  Switching modes is accomplished by modifying certain bits of the processor's control registers after some preparation, and some additional setup may b\"}]","[{\"text\":\"e required after the switch.\\n\\n\\n=== Examples ===\\nWith a computer running legacy BIOS, the BIOS and the boot loader is running in Real mode, then the 64-bit operating system kernel checks and switches the CPU into Long mode and then starts new kernel-mode threads runn\"}]","[{\"text\":\"ing 64-bit code.\\nWith a computer running UEFI, the UEFI firmware (except CSM and legacy Option ROM), the UEFI boot loader and the UEFI operating system kernel is all running in Long mode.\\n\\n\\n== Instruction types ==\\nIn general, the features of the modern x86 instructi\"}]","[{\"text\":\"on set are:\\n\\nA compact encoding\\nVariable length and alignment independent (encoded as little endian, as is all data in the x86 architecture)\\nMainly one-address and two-address instructions, that is to say, the first operand is also the destination.\\nMemory operands a\"}]","[{\"text\":\"s both source and destination are supported (frequently used to read/write stack elements addressed using small immediate offsets).\\nBoth general and implicit register usage; although all seven (counting ebp) general registers in 32-bit mode, and all fifteen (countin\"}]","[{\"text\":\"g rbp) general registers in 64-bit mode, can be freely used as accumulators or for addressing, most of them are also implicitly used by certain (more or less) special instructions; affected registers must therefore be temporarily preserved (normally stacked), if act\"}]","[{\"text\":\"ive during such instruction sequences.\\nProduces conditional flags implicitly through most integer ALU instructions.\\nSupports various addressing modes including immediate, offset, and scaled index but not PC-relative, except jumps (introduced as an improvement in th\"}]","[{\"text\":\"e x86-64 architecture).\\nIncludes floating point to a stack of registers.\\nContains special support for atomic read-modify-write instructions (xchg, cmpxchg/cmpxchg8b, xadd, and integer instructions which combine with the lock prefix)\\nSIMD instructions (instructions w\"}]","[{\"text\":\"hich perform parallel simultaneous single instructions on many operands encoded in adjacent cells of wider registers).\\n\\n\\n=== Stack instructions ===\\nThe x86 architecture has hardware support for an execution stack mechanism. Instructions such as push, pop, call and r\"}]","[{\"text\":\"et are used with the properly set up stack to pass parameters, to allocate space for local data, and to save and restore call-return points. The ret size instruction is very useful for implementing space efficient (and fast) calling conventions where the callee is r\"}]","[{\"text\":\"esponsible for reclaiming stack space occupied by parameters.\\nWhen setting up a stack frame to hold local data of a recursive procedure there are several choices; the high level enter instruction (introduced with the 80186) takes a procedure-nesting-depth argument a\"}]","[{\"text\":\"s well as a local size argument, and may be faster than more explicit manipulation of the registers (such as push bp ; mov bp, sp ; sub sp, size).  Whether it is faster or slower depends on the particular x86-processor implementation as well as the calling conventio\"}]","[{\"text\":\"n used by the compiler, programmer or particular program code; most x86 code is intended to run on x86-processors from several manufacturers and on different technological generations of processors, which implies highly varying microarchitectures and microcode solut\"}]","[{\"text\":\"ions as well as varying gate- and transistor-level design choices.\\nThe full range of addressing modes (including immediate and base+offset) even for instructions such as push and pop, makes direct usage of the stack for integer, floating point and address data simpl\"}]","[{\"text\":\"e, as well as keeping the ABI specifications and mechanisms relatively simple compared to some RISC architectures (require more explicit call stack details).\\n\\n\\n=== Integer ALU instructions ===\\nx86 assembly has the standard mathematical operations, add, sub, mul, wit\"}]","[{\"text\":\"h idiv; the logical operators and, or, xor, neg; bitshift arithmetic and logical, sal/sar, shl/shr; rotate with and without carry, rcl/rcr, rol/ror, a complement of BCD arithmetic instructions, aaa, aad, daa and others.\\n\\n\\n=== Floating-point instructions ===\\nx86 asse\"}]","[{\"text\":\"mbly language includes instructions for a stack-based floating-point unit (FPU). The FPU was an optional separate coprocessor for the 8086 through the 80386, it was an on-chip option for the 80486 series, and it is a standard feature in every Intel x86 CPU since th\"}]","[{\"text\":\"e 80486, starting with the Pentium. The FPU instructions include addition, subtraction, negation, multiplication, division, remainder, square roots, integer truncation, fraction truncation, and scale by power of two. The operations also include conversion instructio\"}]","[{\"text\":\"ns, which can load or store a value from memory in any of the following formats: binary-coded decimal, 32-bit integer, 64-bit integer, 32-bit floating-point, 64-bit floating-point or 80-bit floating-point (upon loading, the value is converted to the currently used f\"}]","[{\"text\":\"loating-point mode). x86 also includes a number of transcendental functions, including sine, cosine, tangent, arctangent, exponentiation with the base 2 and logarithms to bases 2, 10, or e.\\nThe stack register to stack register format of the instructions is usually f\"}]","[{\"text\":\"op st, st(n) or fop st(n), st, where st is equivalent to st(0), and st(n) is one of the 8 stack registers (st(0), st(1), ..., st(7)). Like the integers, the first operand is both the first source operand and the destination operand. fsubr and fdivr should be single\"}]","[{\"text\":\"d out as first swapping the source operands before performing the subtraction or division. The addition, subtraction, multiplication, division, store and comparison instructions include instruction modes that pop the top of the stack after their operation is complet\"}]","[{\"text\":\"e. So, for example, faddp st(1), st performs the calculation st(1) = st(1) + st(0), then removes st(0) from the top of stack, thus making what was the result in st(1) the top of the stack in st(0).\\n\\n\\n=== SIMD instructions ===\\nModern x86 CPUs contain SIMD instruction\"}]","[{\"text\":\"s, which largely perform the same operation in parallel on many values encoded in a wide SIMD register. Various instruction technologies support different operations on different register sets, but taken as complete whole (from MMX to SSE4.2) they include general co\"}]","[{\"text\":\"mputations on integer or floating point arithmetic (addition, subtraction, multiplication, shift, minimization, maximization, comparison, division or square root). So for example, paddw mm0, mm1 performs 4 parallel 16-bit (indicated by the w) integer adds (indicate\"}]","[{\"text\":\"d by the padd) of mm0 values to mm1 and stores the result in mm0. Streaming SIMD Extensions or SSE also includes a floating point mode in which only the very first value of the registers is actually modified (expanded in SSE2). Some other unusual instructions have b\"}]","[{\"text\":\"een added including a sum of absolute differences (used for motion estimation in video compression, such as is done in MPEG) and a 16-bit multiply accumulation instruction (useful for software-based alpha-blending and digital filtering). SSE (since SSE3) and 3DNow! \"}]","[{\"text\":\"extensions include addition and subtraction instructions for treating paired floating point values like complex numbers.\\nThese instruction sets also include numerous fixed sub-word instructions for shuffling, inserting and extracting the values around within the reg\"}]","[{\"text\":\"isters. In addition there are instructions for moving data between the integer registers and XMM (used in SSE)/FPU (used in MMX) registers.\\n\\n\\n=== Data manipulation instructions ===\\nThe x86 processor also includes complex addressing modes for addressing memory with a\"}]","[{\"text\":\"n immediate offset, a register, a register with an offset, a scaled register with or without an offset, and a register with an optional offset and another scaled register. So for example, one can encode mov eax, [Table + ebx + esi*4] as a single instruction which lo\"}]","[{\"text\":\"ads 32 bits of data from the address computed as (Table + ebx + esi * 4) offset from the ds selector, and stores it to the eax register. In general x86 processors can load and use memory matched to the size of any register it is operating on. (The SIMD instructions \"}]","[{\"text\":\"also include half-load instructions.)\\nThe x86 instruction set includes string load, store, move, scan and compare instructions (lods, stos, movs, scas and cmps) which perform each operation to a specified size (b for 8-bit byte, w for 16-bit word, d for 32-bit doubl\"}]","[{\"text\":\"e word) then increments/decrements (depending on DF, direction flag) the implicit address register (si for lods, di for stos and scas, and both for movs and cmps). For the load, store and scan operations, the implicit target/source/comparison register is in the al, \"}]","[{\"text\":\"ax or eax register (depending on size). The implicit segment registers used are ds for si and es for di. The cx or ecx register is used as a decrementing counter, and the operation stops when the counter reaches zero or (for scans and comparisons) when inequality i\"}]","[{\"text\":\"s detected.\\nThe stack is implemented with an implicitly decrementing (push) and incrementing (pop) stack pointer. In 16-bit mode, this implicit stack pointer is addressed as SS:[SP], in 32-bit mode it is SS:[ESP], and in 64-bit mode it is [RSP]. The stack pointer ac\"}]","[{\"text\":\"tually points to the last value that was stored, under the assumption that its size will match the operating mode of the processor (i.e., 16, 32, or 64 bits) to match the default width of the push/pop/call/ret instructions. Also included are the instructions enter a\"}]","[{\"text\":\"nd leave which reserve and remove data from the top of the stack while setting up a stack frame pointer in bp/ebp/rbp. However, direct setting, or addition and subtraction to the sp/esp/rsp register is also supported, so the enter/leave instructions are generally un\"}]","[{\"text\":\"necessary.\\nThis code in the beginning of a function:\\n\\n...is functionally equivalent to just:\\n\\nOther instructions for manipulating the stack include pushf/popf for storing and retrieving the (E)FLAGS register. The pusha/popa instructions will store and retrieve the e\"}]","[{\"text\":\"ntire integer register state to and from the stack.\\nValues for a SIMD load or store are assumed to be packed in adjacent positions for the SIMD register and will align them in sequential little-endian order. Some SSE load and store instructions require 16-byte align\"}]","[{\"text\":\"ment to function properly. The SIMD instruction sets also include \\\"prefetch\\\" instructions which perform the load but do not target any register, used for cache loading. The SSE instruction sets also include non-temporal store instructions which will perform stores s\"}]","[{\"text\":\"traight to memory without performing a cache allocate if the destination is not already cached (otherwise it will behave like a regular store.)\\nMost generic integer and floating point (but no SIMD) instructions can use one parameter as a complex address as the secon\"}]","[{\"text\":\"d source parameter. Integer instructions can also accept one memory parameter as a destination operand.\\n\\n\\n== Program flow ==\\nThe x86 assembly has an unconditional jump operation, jmp, which can take an immediate address, a register or an indirect address as a parame\"}]","[{\"text\":\"ter (note that most RISC processors only support a link register or short immediate displacement for jumping).\\nAlso supported are several conditional jumps, including jz (jump on zero), jnz (jump on non-zero), jg (jump on greater than, signed), jl (jump on less than\"}]","[{\"text\":\", signed), ja (jump on above/greater than, unsigned), jb (jump on below/less than, unsigned). These conditional operations are based on the state of specific bits in the (E)FLAGS register. Many arithmetic and logic operations set, clear or complement these flags dep\"}]","[{\"text\":\"ending on their result. The comparison cmp (compare) and test instructions set the flags as if they had performed a subtraction or a bitwise AND operation, respectively, without altering the values of the operands. There are also instructions such as clc (clear carr\"}]","[{\"text\":\"y flag) and cmc (complement carry flag) which work on the flags directly. Floating point comparisons are performed via fcom or ficom instructions which eventually have to be converted to integer flags.\\nEach jump operation has three different forms, depending on the \"}]","[{\"text\":\"size of the operand. A short jump uses an 8-bit signed operand, which is a relative offset from the current instruction. A near jump is similar to a short jump but uses a 16-bit signed operand  (in real or protected mode) or a 32-bit signed operand (in 32-bit protec\"}]","[{\"text\":\"ted mode only). A far jump is one that uses the full segment base:offset value as an absolute address. There are also indirect and indexed forms of each of these.\\nIn addition to the simple jump operations, there are the call (call a subroutine) and ret (return from \"}]","[{\"text\":\"subroutine) instructions. Before transferring control to the subroutine, call pushes the segment offset address of the instruction following the call onto the stack; ret pops this value off the stack, and jumps to it, effectively returning the flow of control to tha\"}]","[{\"text\":\"t part of the program. In the case of a far call, the segment base is pushed following the offset; far ret pops the offset and then the segment base to return.\\nThere are also two similar instructions, int (interrupt), which saves the current (E)FLAGS register value \"}]","[{\"text\":\"on the stack, then performs a far call, except that instead of an address, it uses an interrupt vector, an index into a table of interrupt handler addresses. Typically, the interrupt handler saves all other CPU registers it uses, unless they are used to return the r\"}]","[{\"text\":\"esult of an operation to the calling program (in software called interrupts). The matching return from interrupt instruction is iret, which restores the flags after returning. Soft Interrupts of the type described above are used by some operating systems for system \"}]","[{\"text\":\"calls, and can also be used in debugging hard interrupt handlers. Hard interrupts are triggered by external hardware events, and must preserve all register values as the state of the currently executing program is unknown. In Protected Mode, interrupts may be set u\"}]","[{\"text\":\"p by the OS to trigger a task switch, which will automatically save all registers of the active task.\\n\\n\\n== Examples ==\\n\\n\\n=== \\\"Hello world!\\\" program for DOS in MASM style assembly ===\\nUsing interrupt 21h for output – other samples use libc's printf to print to stdout\"}]","[{\"text\":\".\\n\\n\\n=== \\\"Hello world!\\\" program for Windows in MASM style assembly ===\\n\\n\\n=== \\\"Hello world!\\\" program for Windows in NASM style assembly ===\\n\\n\\n=== \\\"Hello world!\\\" program for Linux in NASM style assembly ===\\n\\n\\n=== \\\"Hello world!\\\" program for Linux in NASM style assembly \"}]","[{\"text\":\"using the C standard library ===\\n\\n\\n=== \\\"Hello world!\\\" program for 64-bit mode Linux in NASM style assembly ===\\n\\nRunning it under strace verifies that no extra system calls are made in the process.  The printf version would make many more system calls to initialize l\"}]","[{\"text\":\"ibc and do dynamic linking.  But this is a static executable because we linked using ld without -pie or any shared libraries; the only instructions that run in user-space are the ones you provide.\\n\\n\\n=== Using the flags register ===\\nFlags are heavily used for compari\"}]","[{\"text\":\"sons in the x86 architecture. When a comparison is made between two data, the CPU sets the relevant flag or flags. Following this, conditional jump instructions can be used to check the flags and branch to code that should run, e.g.:\\n\\nFlags are also used in the x86 \"}]","[{\"text\":\"architecture to turn on and off certain features or execution modes. For example, to disable all maskable interrupts, you can use the instruction:\\n\\nThe flags register can also be directly accessed. The low 8 bits of the flag register can be loaded into ah using the \"}]","[{\"text\":\"lahf instruction. The entire flags register can also be moved on and off the stack using the instructions pushf, popf, int (including into) and iret.\\n\\n\\n=== Using the instruction pointer register ===\\nThe instruction pointer is called ip in 16-bit mode, eip in 32-bit \"}]","[{\"text\":\"mode, and rip in 64-bit mode.  The instruction pointer register points to the memory address which the processor will next attempt to execute; it cannot be directly accessed in 16-bit or 32-bit mode, but a sequence like the following can be written to put the addres\"}]","[{\"text\":\"s of next_line into eax:\\n\\nThis sequence of instructions generates position-independent code because call takes an instruction-pointer-relative immediate operand describing the offset in bytes of the target instruction from the next instruction (in this case 0).\\nWrit\"}]","[{\"text\":\"ing to the instruction pointer is simple — a jmp instruction sets the instruction pointer to the target address, so, for example, a sequence like the following will put the contents of eax into eip:\\n\\nIn 64-bit mode, instructions can reference data relative to the in\"}]","[{\"text\":\"struction pointer, so there is less need to copy the value of the instruction pointer to another register.\\n\\n\\n== See also ==\\nAssembly language\\nX86 instruction listings\\nX86 architecture\\nCPU design\\nList of assemblers\\nSelf-modifying code\\nDOS\\n\\n\\n== References ==\\n\\n\\n== Furt\"}]","[{\"text\":\"her reading ==\\n\\n\\n=== Manuals ===\\nIntel 64 and IA-32 Software Developer Manuals\\nAMD64 Architecture Programmer's Manual (Volume 1-5)\\n\\n\\n=== Books ===\\nEd, Jorgensen (May 2018). x86-64 Assembly Language Programming with Ubuntu (PDF) (1.0.97 ed.). p. 367.\"}]"]} 1
